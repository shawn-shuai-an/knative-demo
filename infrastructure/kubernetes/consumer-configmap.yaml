apiVersion: v1
kind: ConfigMap
metadata:
  name: consumer-config
  namespace: knative-demo
data:
  requirements.txt: |
    Flask==2.3.2
    cloudevents==1.10.1
  
  consumer.py: |
    #!/usr/bin/env python3
    """
    ç®€åŒ–ç‰ˆäº‹ä»¶æ¶ˆè´¹è€… - æ¥æ”¶å’Œå¤„ç†æ¥è‡ª Knative Broker çš„ CloudEvents
    """
    
    import os
    import json
    import time
    import logging
    from datetime import datetime
    from typing import Dict, Any, Optional
    
    from flask import Flask, request, jsonify
    from cloudevents.http import from_http
    
    # é…ç½®æ—¥å¿—
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s'
    )
    logger = logging.getLogger(__name__)
    
    app = Flask(__name__)
    
    # ç¯å¢ƒå˜é‡é…ç½®
    LOG_LEVEL = os.getenv('LOG_LEVEL', 'INFO')
    PROCESSING_DELAY = int(os.getenv('PROCESSING_DELAY', 1))
    PORT = int(os.getenv('PORT', 8080))
    
    # è®¾ç½®æ—¥å¿—çº§åˆ«
    logging.getLogger().setLevel(getattr(logging, LOG_LEVEL.upper()))
    
    class SimpleEventProcessor:
        """ç®€åŒ–çš„äº‹ä»¶å¤„ç†å™¨"""
        
        def __init__(self):
            self.processed_events = 0
            self.failed_events = 0
            self.start_time = time.time()
            
            logger.info("ğŸš€ Event processor initialized")
            logger.info(f"   Processing delay: {PROCESSING_DELAY} seconds")
            logger.info(f"   Log level: {LOG_LEVEL}")
        
        def process_demo_event(self, event_data: Dict[str, Any]) -> Dict[str, Any]:
            """å¤„ç†æ¼”ç¤ºäº‹ä»¶"""
            message = event_data.get('message', 'No message')
            logger.info(f"ğŸ¯ Processing demo event: {message}")
            
            # æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
            time.sleep(PROCESSING_DELAY)
            
            return {
                'status': 'processed',
                'event_type': 'demo.event',
                'original_message': message,
                'processed_at': datetime.utcnow().isoformat(),
                'processing_time': PROCESSING_DELAY
            }
        
        def process_user_created_event(self, event_data: Dict[str, Any]) -> Dict[str, Any]:
            """å¤„ç†ç”¨æˆ·åˆ›å»ºäº‹ä»¶"""
            user_id = event_data.get('user_id', 'unknown')
            username = event_data.get('username', 'unknown')
            email = event_data.get('email', 'unknown')
            
            logger.info(f"ğŸ‘¤ Processing user created: {username} ({user_id})")
            
            # æ¨¡æ‹Ÿå¤„ç†æ­¥éª¤
            processing_steps = [
                f"âœ… Validate user data for {username}",
                f"âœ… Send welcome email to {email}",
                f"âœ… Initialize user preferences",
                f"âœ… Log user registration: {user_id}"
            ]
            
            for step in processing_steps:
                logger.info(f"   {step}")
                time.sleep(0.2)  # æ¨¡æ‹Ÿæ¯ä¸ªæ­¥éª¤çš„å¤„ç†æ—¶é—´
            
            return {
                'status': 'processed',
                'event_type': 'user.created',
                'user_id': user_id,
                'username': username,
                'processing_steps': processing_steps,
                'processed_at': datetime.utcnow().isoformat()
            }
        
        def process_order_placed_event(self, event_data: Dict[str, Any]) -> Dict[str, Any]:
            """å¤„ç†è®¢å•åˆ›å»ºäº‹ä»¶"""
            order_id = event_data.get('order_id', 'unknown')
            user_id = event_data.get('user_id', 'unknown')
            amount = event_data.get('amount', 0)
            items = event_data.get('items', [])
            
            logger.info(f"ğŸ›’ Processing order: {order_id} (User: {user_id}, Amount: ${amount})")
            logger.info(f"   Items: {', '.join(items)}")
            
            # æ¨¡æ‹Ÿè®¢å•å¤„ç†é€»è¾‘
            processing_steps = [
                f"âœ… Validate order {order_id}",
                f"âœ… Check inventory for {len(items)} items",
                f"âœ… Process payment: ${amount}",
                f"âœ… Send order confirmation to user {user_id}"
            ]
            
            for step in processing_steps:
                logger.info(f"   {step}")
                time.sleep(0.3)  # æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
            
            return {
                'status': 'processed',
                'event_type': 'order.placed',
                'order_id': order_id,
                'user_id': user_id,
                'amount': amount,
                'items_count': len(items),
                'processing_steps': processing_steps,
                'processed_at': datetime.utcnow().isoformat()
            }
        
        def process_event(self, cloud_event) -> Dict[str, Any]:
            """æ ¹æ®äº‹ä»¶ç±»å‹å¤„ç†äº‹ä»¶"""
            event_type = cloud_event['type']
            event_data = cloud_event.data or {}
            event_id = cloud_event['id']
            
            logger.info(f"ğŸ“¨ Received event: {event_type} (ID: {event_id[:8]}...)")
            
            try:
                if event_type == 'demo.event':
                    result = self.process_demo_event(event_data)
                elif event_type == 'user.created':
                    result = self.process_user_created_event(event_data)
                elif event_type == 'order.placed':
                    result = self.process_order_placed_event(event_data)
                else:
                    logger.warning(f"â“ Unknown event type: {event_type}")
                    result = {
                        'status': 'unknown_type',
                        'event_type': event_type,
                        'message': f'No handler for event type: {event_type}',
                        'processed_at': datetime.utcnow().isoformat()
                    }
                
                self.processed_events += 1
                logger.info(f"âœ… Event processed successfully (Total: {self.processed_events})")
                return result
                
            except Exception as e:
                self.failed_events += 1
                error_msg = f"ğŸ’¥ Error processing event {event_id}: {str(e)}"
                logger.error(error_msg)
                return {
                    'status': 'error',
                    'error': str(e),
                    'event_id': event_id,
                    'processed_at': datetime.utcnow().isoformat()
                }
    
    # åˆå§‹åŒ–äº‹ä»¶å¤„ç†å™¨
    processor = SimpleEventProcessor()
    
    @app.route('/', methods=['POST'])
    def handle_event():
        """Knative äº‹ä»¶å¤„ç†ç«¯ç‚¹"""
        try:
            # ä» HTTP è¯·æ±‚ä¸­è§£æ CloudEvent
            cloud_event = from_http(request.headers, request.get_data())
            
            # å¤„ç†äº‹ä»¶
            result = processor.process_event(cloud_event)
            
            # è¿”å›æˆåŠŸå“åº” (Knative æœŸæœ› 2xx å“åº”)
            return jsonify({
                'event_id': cloud_event['id'],
                'processing_result': result,
                'timestamp': datetime.utcnow().isoformat()
            }), 200
            
        except Exception as e:
            error_msg = f"ğŸ’¥ Error handling event: {str(e)}"
            logger.error(error_msg)
            # è¿”å›é”™è¯¯å“åº” (Knative ä¼šé‡è¯•)
            return jsonify({
                'error': str(e),
                'timestamp': datetime.utcnow().isoformat()
            }), 500
    
    @app.route('/health', methods=['GET'])
    def health_check():
        """å¥åº·æ£€æŸ¥ç«¯ç‚¹"""
        uptime = time.time() - processor.start_time
        return jsonify({
            'status': 'healthy',
            'service': 'event-consumer',
            'uptime_seconds': round(uptime, 2),
            'processed_events': processor.processed_events,
            'failed_events': processor.failed_events,
            'timestamp': datetime.utcnow().isoformat()
        })
    
    @app.route('/metrics', methods=['GET'])
    def metrics():
        """æŒ‡æ ‡ç«¯ç‚¹"""
        uptime = time.time() - processor.start_time
        total_events = processor.processed_events + processor.failed_events
        
        return jsonify({
            'processed_events': processor.processed_events,
            'failed_events': processor.failed_events,
            'total_events': total_events,
            'success_rate': round((processor.processed_events / max(total_events, 1)) * 100, 2),
            'uptime_seconds': round(uptime, 2),
            'events_per_minute': round((total_events / max(uptime / 60, 1)), 2)
        })
    
    @app.route('/stats', methods=['GET'])
    def stats():
        """è¯¦ç»†ç»Ÿè®¡ä¿¡æ¯"""
        uptime = time.time() - processor.start_time
        total_events = processor.processed_events + processor.failed_events
        
        return jsonify({
            'service': 'event-consumer',
            'statistics': {
                'total_events': total_events,
                'successful_events': processor.processed_events,
                'failed_events': processor.failed_events,
                'success_rate_percent': round((processor.processed_events / max(total_events, 1)) * 100, 2),
                'uptime_seconds': round(uptime, 2),
                'events_per_second': round(total_events / max(uptime, 1), 2),
                'avg_processing_time': PROCESSING_DELAY
            },
            'configuration': {
                'processing_delay': PROCESSING_DELAY,
                'log_level': LOG_LEVEL,
                'port': PORT
            },
            'timestamp': datetime.utcnow().isoformat()
        })
    
    if __name__ == "__main__":
        logger.info(f"ğŸš€ Starting Event Consumer Service on port {PORT}")
        app.run(host='0.0.0.0', port=PORT, debug=False)

  startup.sh: |
    #!/bin/bash
    
    echo "ğŸš€ Starting Knative Event Consumer..."
    
    # å®‰è£…ä¾èµ–
    echo "ğŸ“¦ Installing dependencies..."
    pip install -r /app/requirements.txt --quiet
    
    # ç®€å•æ£€æŸ¥ DNS è§£æ (æ›´å¯é çš„ç½‘ç»œæ£€æŸ¥)
    echo "ğŸŒ Checking network connectivity..."
    if python3 -c "import socket; socket.gethostbyname('kubernetes.default.svc.cluster.local')" &>/dev/null; then
        echo "âœ… Network ready (cluster DNS working)"
    elif python3 -c "import socket; socket.create_connection(('8.8.8.8', 53), timeout=3)" &>/dev/null; then
        echo "âœ… Network ready (external connectivity working)"
    else
        echo "âš ï¸  Network check failed, but proceeding anyway..."
    fi
    
    # ç›´æ¥ä½¿ç”¨ Python è¿è¡Œ (demo ç¯å¢ƒæ›´ç®€å•å¯é )
    echo "ğŸ¯ Starting event consumer..."
    exec python /app/consumer.py 